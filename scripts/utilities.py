"List of utilities for preparing the image data, and retrieving the image data from Roboflow"
import cv2
import os
import logging
import sys
import numpy as np
import shutil
import yaml


def rename_files_in_dir(dir_path:str, txt_to_remove:str,txt_to_insert:str):
    """Rename files in directory.

    Args:
        dir_path (str): path to directory where the files are to be renamed.
        txt_to_remove (str): Text that will be removed from the file name.
        txt_to_insert (str): Text that will be inserted where the removed text initially existed.
    """
    for filename in os.listdir(dir_path):
        full_file_path = os.path.join(dir_path,filename)
        os.rename(full_file_path, full_file_path.replace(txt_to_remove, txt_to_insert))


def convert_mp4_to_jpg(dir_path:str, txt_to_remove:str = '.mp4',txt_to_insert:str = ''):
    """Converts MP4s to JPGs.

    Args:
        dir_path (str): directory path to MP4 clips
        txt_to_remove (str): Text that will be removed from the file name.
        txt_to_insert (str): Text that will be inserted where the removed text initially existed.
    """
    # Read the video from specified path
    for filename in os.listdir(dir_path):
        logging.info(f"Filename: {filename}")
        cam = cv2.VideoCapture(os.path.join(dir_path,filename))
        
        try:
            #Temporary fix for weird file names generated by Adobe
            updated_filename = filename.replace(txt_to_remove,txt_to_insert)
            # creating a folder named data
            new_folder_path = os.path.join(dir_path,updated_filename)
            logging.info(f"Path to file: {new_folder_path}")
            if not os.path.exists(new_folder_path):
                os.makedirs(new_folder_path)
        
        # if not created then raise error
        except OSError:
            logging.error('Error: Creating directory of data')
        
        # frame
        currentframe = 0
        
        while(True):
            # reading from frame
            ret,frame = cam.read()
            
            if ret:
                # if video is still left continue creating images
                name = './'+ new_folder_path +'/frame_' + str(currentframe) + '.jpg'
                logging.info('Creating...' + name)
        
                # writing the extracted images
                cv2.imwrite(name, frame)
        
                # increasing counter so that it will
                # show how many frames are created
                currentframe += 1
            else:
                break
        
        # Release all space and windows once done
        cam.release()
        cv2.destroyAllWindows()
        
def fcount(path, exts=[".jpg"]):
    """Get the number of files that end wih inputted ext.
    
        Args:
        path (str): Directory path of the folder to count files in. 
        exts (list, optional): List of extensions types that will be counted.
    """
    count=0    
    exts=[e.lower() for e in exts]
    for root, dirs, files in os.walk(path):
        for d in dirs:
            p=os.path.join(root, d)
            ff=[fn for fn in os.listdir(p) if any(fn.lower().endswith(e) for e in exts) ]
            if ff:
                count+=len(ff)

    return count 

def get_random_sample(read_path:str,write_path:str,sub_sample:float = 0.05):
    """ Get a list of random sample photos from the directory. This only needs to be done once, during the initial collection of images.
        Args:
        read_path (str): Directoy of where to read the sample from.
        write_path (str, optional): Directory where to write the sample to.
        sub_sample(float,optional): What portion of the total files you would like to retrieve.
    """
    # list all files in dir
    if not os.path.exists(write_path):
        os.makedirs(write_path)
    files = [f for f in os.listdir(read_path) if os.path.isfile(os.path.join(read_path,f))]

    # select sub-sample of the files randomly 
    random_files = np.random.choice(files, int(len(files)*sub_sample))
    files = [shutil.copy(os.path.join(read_path,file),write_path) for file in random_files]

def update_yaml(yaml_path, new_item):
    with open(yaml_path,'r') as yamlfile:
        cur_yaml = yaml.safe_load(yamlfile) # Note the safe_load
        cur_yaml.update(new_item)
    if cur_yaml:
        with open(yaml_path,'w') as yamlfile:
            yaml.safe_dump(cur_yaml, yamlfile) # Also note the safe_dump

def main():
    """Performs a test-run for local testing"""



if __name__ == "__main__":
    main()